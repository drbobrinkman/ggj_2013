;------------------------------------------------
;
; untitled
; Atari VCS Game 
; Created by Bo Brinkman on 2011-09-20.
;
; Logo (c) 2011 __EyeWOL__. All rights reserved.
;
; Use with joystick controllers
;
;------------------------------------------------
	processor 	6502
	include 	vcs.h
	include 	macro.h

;------------------------------------------------
; Constants
;------------------------------------------------
BLACK = #$00
HMOVE_M07          =  $F0
HMOVE_M06          =  $E0
HMOVE_M05          =  $D0
HMOVE_M04          =  $C0
HMOVE_M03          =  $B0
HMOVE_M02          =  $A0
HMOVE_M01          =  $90
HMOVE_0            =  $80
HMOVE_M15          =  $70
HMOVE_M14          =  $60
HMOVE_M13          =  $50
HMOVE_M12          =  $40
HMOVE_M11          =  $30
HMOVE_M10          =  $20
HMOVE_M09          =  $10
HMOVE_M08          =  $00

; values for NUSIZx:
ONE_COPY          = %000
TWO_COPIES        = %001
TWO_WIDE_COPIES   = %010
THREE_COPIES      = %011 
DOUBLE_SIZE       = %101 
THREE_MED_COPIES  = %110 
QUAD_SIZE         = %111

; values for REFPx:
NO_REFLECT        = %0000
REFLECT           = %1000

; mask for SWCHB
P1_DIFF_MASK      = %10000000
BW_MASK           = %00001000       ; black and white bit
SELECT_MASK       = %00000010
RESET_MASK        = %00000001

;Joystick masks
P0_RIGHT_MASK 	= %10000000
P0_LEFT_MASK 	= %01000000
P0_DOWN_MASK 	= %00100000
P0_UP_MASK 		= %00010000

NOTE_C2 = 26 ;12
NOTE_BF2 = 14
NOTE_A2	= 15
NOTE_G	= 17
NOTE_F	= 19
NOTE_E	= 20
NOTE_D	= 23
NOTE_C	= 26
NOTE_A	= 31

NOTE_ATTACK = 32

TICKS_PER_COUNT = 24

SCORE_TO_SEE_BABY = $05
SCORE_FOR_BG = 64
SCORE_FOR_SONG = 96

PLAYER_COLOR = $8c
BABY_COLOR = $6c

H_EDGE = 132
V_EDGE = 162

;------------------------------------------------
; RAM
;------------------------------------------------
    SEG.U   variables
    ORG     $80

ticks .byte

plrX  .byte
plrY  .byte

musicTicks .byte
musicCount .byte

envelope		  .byte
songVol	.byte

bgIndex .byte

tgtX	.byte
tgtY	.byte

tgtTargetX .byte
tgtTargetY .byte

score   .byte

maxHBVolume .byte
temp	.byte

bgMask .byte

totalDist .byte
babySpeed .byte
aiDir	  .byte

;--This is the real "Score"
timeSpentWithBabySec .byte
timeSpentWithBabyMin .byte
timerTicks			.byte

scorePF1	.byte
scorePF2	.byte
scoreColor  .byte
madeMusic   .byte

;------------------------------------------------
; Start of ROM
;------------------------------------------------
	SEG   Bank0
	ORG   $F000       	; 4k ROM start point
Start
	CLEAN_START ; Clear RAM and Registers
;------------------------------------------------
; Vertical Blank
;------------------------------------------------
AttractMainLoop
	lda		#0		;Start the vertical blank
	sta		VBLANK
	VERTICAL_SYNC
    lda     #43
    sta     TIM64T ;This sets a timer that we can check via INTIM

	;***** Vertical Blank code goes here
	;--Handle reset switch
	lda		SWCHB
	and		#%00000001
	beq		RealStart

.attractWaitForVBlank
	lda		INTIM
	bne		.attractWaitForVBlank
	sta		WSYNC


;------------------------------------------------
; Kernel
;------------------------------------------------	
AttractDrawScreen

    ; Kernel goes here.	
	;Pixel aspect ratio is 12:7

	;---Top zone, no player/target
	ldx		#192+1		 	
.attractScanline
	dex
	sta		WSYNC
	bne		.attractScanline				
;--end bottom zone			

;------------------------------------------------
; Overscan
;------------------------------------------------
	lda		#%01000010
	sta		VBLANK
    lda		#36
    sta		TIM64T

	;***** Overscan Code goes here

.attractWaitForOverscan
	lda     INTIM
	bne     .attractWaitForOverscan
	jmp		AttractMainLoop
	
	
	
	
	
	
	
	
	
	
RealStart 
	CLEAN_START			; Clear RAM and Registers
	
	lda		#0
	sta		ticks	;initialize ticks	
	
	;Initialize colors		
	lda		#PLAYER_COLOR ;Player color
	sta		COLUP0
	sta		scoreColor ;--Use player color for score color too
	
	;Initialize player to center of the screen
	lda		#76
	sta		tgtX
	lda		#92
	sta		tgtY
	lda		#0

	sta		COLUP1
	sta		bgMask
	sta		songVol
	
	lda     #76
	sta		plrX
	lda		#92
	sta		plrY
	
	lda		#$FF
	sta		GRP0
	
	lda		#3
	sta		AUDV0
	lda		#27
	sta		AUDF0
	lda		#8
	sta		AUDC0
	
	lda     #0
	sta		AUDV1
	lda		#12
	sta		AUDC1
	
	lda 	#00
	sta		musicTicks
	sta 	musicCount
	sta		envelope
	sta		aiDir
	sta		timeSpentWithBabySec
	sta		timeSpentWithBabyMin
	sta		timerTicks
	sta		scorePF1
	sta		scorePF2
	sta		madeMusic
	
	lda		#2
	sta		maxHBVolume

	lda		#0
	sta		score
	lda		#1
	sta		babySpeed
	sta		CTRLPF ;--Want playfield reflection
	
;------------------------------------------------
; Vertical Blank
;------------------------------------------------
MainLoop
	lda		#0		;Start the vertical blank
	sta		VBLANK
	VERTICAL_SYNC
    lda     #43
    sta     TIM64T ;This sets a timer that we can check via INTIM

	;***** Vertical Blank code goes here
	
	;--Handle reset switch
	lda		SWCHB
	and		#%00000001
	bne		.notRealStart
	jmp		RealStart
.notRealStart	

	;** Increment ticks
	lda		timerTicks
	clc
	adc		#1
	cmp		#60
	bne		.noTimerTickReset
	lda		#0
.noTimerTickReset
	clc
	sta		timerTicks
	
	lda		ticks
	clc
	adc		#4
	cmp		#96
	bne		.noTickReset
	lda		#0
.noTickReset
	clc
	sta 	ticks
	sta		bgIndex
	
	;Want the heartbeat sound to go up and down in 
	; volume, to make the "beat" effect
	lda		ticks
	lsr
	lsr
	lsr
	cmp		#8
	bmi		.goingUp
	eor     #%00001111
.goingUp
	adc		#1
	;and     maxHBVolume
	asl
.decreaseVol
	lsr
	cmp		maxHBVolume
	bpl		.decreaseVol
	
	sta		AUDV0
	
;*** Read the joystick
	lda 	#P0_RIGHT_MASK
	bit		SWCHA
	bne		.notRight
	
	lda		plrX
	cmp		#132	
	beq		.notRight
	adc		#1
	sta		plrX
	
.notRight
	lda		#P0_LEFT_MASK
	bit		SWCHA
	bne		.notLeft
	
	lda		plrX
	cmp		#20
	beq		.notLeft
	sbc		#1
	sta		plrX
.notLeft
	
	
	lda 	#P0_UP_MASK
	bit		SWCHA
	bne		.notUp

	lda		plrY
	cmp		#162
	beq		.notUp
	adc		#2
	sta		plrY

.notUp
	lda		#P0_DOWN_MASK
	bit		SWCHA
	bne		.notDown

	lda		plrY
	cmp		#38
	beq		.notDown
	sbc		#2
	sta		plrY
.notDown
	;jmp		$F100
	
	;ORG $F100	
	;** Place the player sprite
	sta 	WSYNC
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	lda		plrX
.pos_loop_plr
	sbc		#15				;(2)
	bpl		.pos_loop_plr	;(3)
	
	sta		RESP0			;(3)

	sta		WSYNC	
	eor		#255			;(2)
	tax	
	lda		.hmove_table,x	;(4)
	sta		HMP0			;(3)
	
	sta		WSYNC
	;sta		HMOVE
	
	;Clear the player1 sprite
	lda		#0
	sta		GRP0
	;sta		HMP0
	
	
	;** Place the target sprite
	sta 	WSYNC
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	lda		tgtX
.pos_loop_tgt
	sbc		#15				;(2)
	bpl		.pos_loop_tgt	;(3)

	sta		RESP1			;(3)

	sta		WSYNC	
	eor		#255			;(2)
	tax	
	lda		.hmove_table,x	;(4)
	sta		HMP1			;(3)

	sta		WSYNC
	sta		HMOVE

	;Clear the player1 sprite
	lda		#0
	sta		GRP1
	;sta		HMP1	
	
	
	
	
	
	lda		musicTicks
	adc		#1
	sta		musicTicks
	cmp		TICKS_PER_COUNT
	bne		.notCountTime
	lda 	#0
	sta		musicTicks
	inc		musicCount

	lda		musicCount
	cmp		#96
	bne		.notCountTime
	lda		#0
	sta		musicCount
	
.notCountTime
		
	lda		musicTicks
	bne		.notAttack ;--Cannot be an attack if it isn't a new count
	
	ldx		musicCount
	lda		.song,x
	sta		AUDF1
	;Is this the start of a new note?
	and		NOTE_ATTACK
	beq		.notAttack
	lda		songVol	;Starting volume level
	sta		envelope
	
	
.notAttack
	
	lda envelope
	sta	AUDV1
	
	lda envelope
	cmp #9
	bmi	.envelopeDone
	dec envelope
.envelopeDone
	
	;--Clear collisions 
	sta		CXCLR
	
	;--Set the HB volume based on distance
	lda		#16
	sta		maxHBVolume
	
	lda		plrX
	sbc		tgtX
	bpl		.isPositiveX
	eor		#$FF
.isPositiveX
	sta		temp
	lda		plrY
	sbc		tgtY
	bpl		.isPositiveY
	eor		#$FF
.isPositiveY
	adc		temp
	sta		totalDist
.adjustVolume
	dec 	maxHBVolume
	dec		maxHBVolume
	lsr
	bne	 	.adjustVolume
	lda		maxHBVolume ;;Never let volume get below 1
	ora		#1
	sta		maxHBVolume
	
	;--Points are scored when maxHBVolume is 0E or 0F. Lose points when < 06
	cmp		#$04 ;;TODO change back to 5 when done testing
	bmi		.loseScore
	cmp		#$07 ;;TODO change back to 8 when done testing
	bmi		.doneScore
	inc		score
	jmp		.doneScore
.loseScore
	dec score
	bpl .doneScore
	inc score ;--Correct if the score went negative
.doneScore
	lda	score
	cmp	#127 ;--127 is the max score, 0 is the min
	bne	.scoreNotTooBig
	dec score
.scoreNotTooBig
	cmp	#255
	bne	.scoreNotTooSmall
	inc score
.scoreNotTooSmall
	
	;--If score is high enough, make the "baby" visible
	lda		score
	cmp		#SCORE_TO_SEE_BABY
	bpl		.visibleBaby
	lda		#$00
	sta		COLUP1
	jmp 	.doneBaby
.visibleBaby
	lda		#BABY_COLOR
	sta		COLUP1
.doneBaby

	;---Which AI version we used is based on what stage
	lda		score
	cmp		#SCORE_TO_SEE_BABY
	bpl		.visibleBabyEvasionCode

	;----AI EVASION CODE

	;--AI CODE for invisible baby stage
	;--When the baby is invisible, stay put!
	jmp		.endAICode

		
;	lda		plrX
;	sbc		tgtX
	;--If this is a small positive number,
	;  we are to the left of the player, and we need to run.
	;  If it is a small positive number, we are to the left, and need to run
;	bpl		.dontRunRight
;	lda 	tgtX
;	adc		babySpeed
;	sta		tgtX
;	jmp		.horizRunDone
;.dontRunRight
;	lda		tgtX
;	sbc		babySpeed
;	sta		tgtX
;.horizRunDone
	;20 to 132
;	lda		tgtX
;	cmp		#132
;	bmi		.tgtXNotTooBig
;	lda		#132
;.tgtXNotTooBig
;	cmp		#20
;	bpl		.tgtXNotTooSmall
;	lda		#20
;.tgtXNotTooSmall
;	sta		tgtX
	
	
;	lda		plrY
;	sbc		tgtY
	;--If this is a positive number,
	;  we are to the below of the player, and we need to run.
	;  otherwise we are to the up, and need to run
;	bpl		.dontRunDown
;.doRunDown
;	lda 	tgtY
;	adc		babySpeed
;	adc		babySpeed
;	sta		tgtY
;	jmp		.vertRunDone
;.dontRunDown
;	lda		tgtY
;	sbc		babySpeed
;	sbc		babySpeed
;	sta		tgtY
;.vertRunDone
	;20 to 132
;	lda		tgtY
;	cmp		#162
;	bmi		.tgtYNotTooBig
;	lda		#162
;.tgtYNotTooBig
;	cmp		#38
;	bpl		.tgtYNotTooSmall
;	lda		#38
;.tgtYNotTooSmall
;	sta		tgtY

.visibleBabyEvasionCode	
	;--GOAL: Reach the point diametrically opposite from the player
	lda		plrX
	cmp		#76
	bpl		.playerIsRight
	lda		#132
	sta		tgtTargetX
	jmp		.playerIsLeft
.playerIsRight
	lda		#20
	sta		tgtTargetX
.playerIsLeft
	
	lda		plrY
	cmp		#100
	bpl		.playerIsUp
	lda		#162
	sta		tgtTargetY
	jmp		.playerIsDown
.playerIsUp
	lda		#38
	sta		tgtTargetY
.playerIsDown


	lda		plrY
	lsr
	eor		plrX
	and		#%00000001
	beq		.doY
	
	lda		tgtTargetX
	sbc		tgtX
	bpl		.runRight
	lda 	tgtX
	sbc		babySpeed
	sta		tgtX
	jmp		.horizRunDone
.runRight
	lda		tgtX
	adc		babySpeed
	sta		tgtX
.horizRunDone
	;20 to 132
	lda		tgtX
	cmp		#132
	bmi		.tgtXNotTooBig
	lda		#132
.tgtXNotTooBig
	cmp		#20
	bpl		.tgtXNotTooSmall
	lda		#20
.tgtXNotTooSmall
	sta		tgtX
	jmp		.noDoY
	
.doY	
	lda		tgtTargetY
	sbc		tgtY
	bpl		.doRunDown
	lda 	tgtY
	sbc		babySpeed
	sbc		babySpeed
	sta		tgtY
	jmp		.vertRunDone
.doRunDown
	lda		tgtY
	adc		babySpeed
	adc		babySpeed
	sta		tgtY
.vertRunDone
	;20 to 132
	lda		tgtY
	cmp		#162
	bmi		.tgtYNotTooBig
	lda		#162
.tgtYNotTooBig
	cmp		#38
	bpl		.tgtYNotTooSmall
	lda		#38
.tgtYNotTooSmall
	sta		tgtY
.noDoY
	jmp		.endAICode
	
.endAICode
;---END AI CODE	
	
	
	
	
	lda		score
	cmp		#SCORE_FOR_BG
	bpl		.yesBG
	lda		#0
	sta		bgMask
	lda		#1
	sta		babySpeed
	jmp		.doneBGMask
.yesBG
	lda		#$FF
	sta		bgMask
	lda		#1 ;--For now, stick with slow baby
	sta		babySpeed
	;Add to the "time with Baby",
	; but only do it once per second
	lda		timerTicks
	bne		.doneBGMask
	lda		timeSpentWithBabySec
	adc		#1
	cmp		#60
	bne		.notBabyMinute
	;;NOTE:Not handling overflow of minutes!
	inc		timeSpentWithBabyMin	
	lda		#0
.notBabyMinute
	sta		timeSpentWithBabySec
.doneBGMask
	
	
	lda		score
	cmp		#SCORE_FOR_SONG
	bpl		.yesSongVol
	lda		#0
	sta		songVol
	jmp		.doneSongVol
.yesSongVol
	lda		score
	sbc		#SCORE_FOR_SONG
	lsr
	sta		songVol
	lda		#1
	sta		madeMusic
.doneSongVol
	
	;Score color changes at each minute
	lda		timeSpentWithBabyMin
	asl
	asl
	asl
	asl
	and		#%11110000
	ora		#$0A
	sta		scoreColor
	
	;Color in 1 bar for each 4 seconds
	lda		#%00000000
	sta		scorePF2
	sta		scorePF1
	lda		timeSpentWithBabySec
	adc		#4
	lsr
	;lsr
	lsr
	tay
	lda		scorePF2
.scoreCntLoop
	dey
	bmi		.scoreDone
	lsr
	bcc		.noPF1
	inc		scorePF1
.noPF1
	ora		#%10000000
	jmp		.scoreCntLoop
.scoreDone	
	sta		scorePF2
	
	lda		scorePF1
	tay
	lda		#0
.scoreCntLoop2
	dey
	bmi		.scoreDone2
	asl
	ora		#%00000001
	jmp		.scoreCntLoop2
.scoreDone2	
	sta		scorePF1
	
	
	;--Game is over if you have been with baby, then
	;  lose her again
	
	;--You cannot lose until you make music
	lda		madeMusic
	beq		.notALoser
	;--If score falls too low, you lose
	lda		score
	cmp 	#SCORE_FOR_BG
	bpl		.notALoser
	jmp		Start
.notALoser
	
.waitForVBlank
	lda		INTIM
	bne		.waitForVBlank
	sta		WSYNC


;------------------------------------------------
; Kernel
;------------------------------------------------	
DrawScreen
	
    ; Kernel goes here.	
	;Pixel aspect ratio is 12:7
	

	;--Score and other feedback to player goes here
	lda		scorePF1
	sta		PF1
	lda		scorePF2
	sta		PF2
	lda		scoreColor
	sta		COLUPF
	ldx		#11+1		 	
.scoreScanline
	dex
	sta		WSYNC
	bne		.scoreScanline

;--Clear playfield
	lda		#0
	sta		PF2
	sta		PF1
	sta		WSYNC


;---Top zone, no player/target
	ldx		#16
.scanline	
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK
	
	txa
	adc		#28+45+46+45
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player
	lda		#$00
	sta		GRP0
	jmp		.donePlayer
.player
	lda		#$FF
	sta		GRP0
.donePlayer

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset
	lda		#0	
.noBgReset
	sta		bgIndex
	
	dex
	sta		WSYNC
	bne		.scanline 		
;--end top


;--begin first target range
	ldx		#45			
.scanline2
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#28+46+45
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player2
	lda		#$00
	sta		GRP0
	jmp		.donePlayer2
.player2
	lda		#$FF
	sta		GRP0
.donePlayer2

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt2
	lda		#$00
	sta		GRP1
	jmp		.doneTgt2
.tgt2
	lda		#$FF
	sta		GRP1
.doneTgt2

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset2
	lda		#0	
.noBgReset2
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline2
;--end first target



;--begin 2nd target		
	ldx		#46		 	
.scanline3
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#28+45
	tay		;Store to use for positioning the target
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player3
	lda		#$00
	sta		GRP0
	jmp		.donePlayer3
.player3
	lda		#$FF
	sta		GRP0
.donePlayer3

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt3
	lda		#$00
	sta		GRP1
	jmp		.doneTgt3
.tgt3
	lda		#$FF
	sta		GRP1
.doneTgt3

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset3
	lda		#0	
.noBgReset3
	sta		bgIndex
	
	dex
	sta		WSYNC
	bne		.scanline3
;--End 2nd target			
			


;--Start 3rd target			
	ldx		#45		
.scanline4
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK
	
	txa
	adc		#28
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player4
	lda		#$00
	sta		GRP0
	jmp		.donePlayer4
.player4
	lda		#$FF
	sta		GRP0
.donePlayer4

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt4
	lda		#$00
	sta		GRP1
	jmp		.doneTgt4
.tgt4
	lda		#$FF
	sta		GRP1
.doneTgt4

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset4
	lda		#0	
.noBgReset4
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline4					
;--end 3rd target

;--Start bottom zone	
	ldx		#28			
.scanline5
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#0
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player5
	lda		#$00
	sta		GRP0
	jmp		.donePlayer5
.player5
	lda		#$FF
	sta		GRP0
.donePlayer5

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt5
	lda		#$00
	sta		GRP1
	jmp		.doneTgt5
.tgt5
	lda		#$FF
	sta		GRP1
.doneTgt5
	
	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset5
	lda		#0	
.noBgReset5
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline5				
;--end bottom zone			
		
;------------------------------------------------
; Overscan
;------------------------------------------------
	lda		#%01000010
	sta		VBLANK
    lda		#36
    sta		TIM64T

	;***** Overscan Code goes here
	lda #$00
	sta COLUBK
	sta COLUPF
	
.waitForOverscan
	lda     INTIM
	bne     .waitForOverscan

	jmp		MainLoop

;------------------------------------------------
; ROM Tables
;------------------------------------------------
	;***** ROM tables go here
	
	ORG $FE00
.hmove_table
	.byte HMOVE_0 
	.byte HMOVE_M01         
	.byte HMOVE_M02        
	.byte HMOVE_M03       
	.byte HMOVE_M04         
	.byte HMOVE_M05          
	.byte HMOVE_M06          
	.byte HMOVE_M07         
	.byte HMOVE_M08       
	.byte HMOVE_M09         
	.byte HMOVE_M10          
	.byte HMOVE_M11          
	.byte HMOVE_M12          
	.byte HMOVE_M13          
	.byte HMOVE_M14          
	.byte HMOVE_M15
	
	;ORG $FE00
.song
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2
	.byte NOTE_A2
	
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_G
	.byte NOTE_G
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2
	.byte NOTE_A2
	
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_G
	.byte NOTE_G
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	
	.byte NOTE_A | NOTE_ATTACK
	.byte NOTE_A
	.byte NOTE_C | NOTE_ATTACK
	.byte NOTE_C
	.byte NOTE_C | NOTE_ATTACK
	.byte NOTE_C
	.byte NOTE_C
	.byte NOTE_C
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_F
	.byte NOTE_F
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	;--Song end
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E

	;ORG $FE00
.bgcolors
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46

	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$4a
	.byte #$4a
	.byte #$4a
	.byte #$4a
	
	.byte #$4e
	.byte #$4e
	.byte #$4e
	.byte #$4e
	
	.byte #$4c
	.byte #$4c
	.byte #$4c
	.byte #$4c
	
	.byte #$4a
	.byte #$4a
	.byte #$4a
	.byte #$4a
	
	.byte #$48
	.byte #$48
	.byte #$48
	.byte #$48
	
	.byte #$48
	.byte #$48
	.byte #$48
	.byte #$48
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
		
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44

	
;------------------------------------------------
; Interrupt Vectors
;------------------------------------------------
	echo [*-$F000]d, " ROM bytes used"
	ORG    $FFFA
	.word  Start         ; NMI
	.word  Start         ; RESET
	.word  Start         ; IRQ
    
	END