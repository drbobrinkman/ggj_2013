;------------------------------------------------
;
; untitled
; Atari VCS Game 
; Created by Bo Brinkman on 2011-09-20.
;
; Logo (c) 2011 __EyeWOL__. All rights reserved.
;
; Use with joystick controllers
;
;------------------------------------------------
	processor 	6502
	include 	vcs.h
	include 	macro.h

;------------------------------------------------
; Constants
;------------------------------------------------
BLACK = #$00
HMOVE_M07          =  $F0
HMOVE_M06          =  $E0
HMOVE_M05          =  $D0
HMOVE_M04          =  $C0
HMOVE_M03          =  $B0
HMOVE_M02          =  $A0
HMOVE_M01          =  $90
HMOVE_0            =  $80
HMOVE_M15          =  $70
HMOVE_M14          =  $60
HMOVE_M13          =  $50
HMOVE_M12          =  $40
HMOVE_M11          =  $30
HMOVE_M10          =  $20
HMOVE_M09          =  $10
HMOVE_M08          =  $00

; values for NUSIZx:
ONE_COPY          = %000
TWO_COPIES        = %001
TWO_WIDE_COPIES   = %010
THREE_COPIES      = %011 
DOUBLE_SIZE       = %101 
THREE_MED_COPIES  = %110 
QUAD_SIZE         = %111

; values for REFPx:
NO_REFLECT        = %0000
REFLECT           = %1000

; mask for SWCHB
P1_DIFF_MASK      = %10000000
BW_MASK           = %00001000       ; black and white bit
SELECT_MASK       = %00000010
RESET_MASK        = %00000001

;Joystick masks
P0_RIGHT_MASK 	= %10000000
P0_LEFT_MASK 	= %01000000
P0_DOWN_MASK 	= %00100000
P0_UP_MASK 		= %00010000

NOTE_C2 = 26 ;12
NOTE_BF2 = 14
NOTE_A2	= 15
NOTE_G	= 17
NOTE_F	= 19
NOTE_E	= 20
NOTE_D	= 23
NOTE_C	= 26
NOTE_A	= 31

NOTE_ATTACK = 32

TICKS_PER_COUNT = 24

SCORE_TO_SEE_BABY = $05
SCORE_FOR_BG = 64
SCORE_FOR_SONG = 96

PLAYER_COLOR = $8c
BABY_COLOR = $6c

H_EDGE = 132
V_EDGE = 162

;------------------------------------------------
; RAM
;------------------------------------------------
    SEG.U   variables
    ORG     $80

ticks .byte

plrX  .byte
plrY  .byte

musicTicks .byte
musicCount .byte

envelope		  .byte
songVol	.byte

bgIndex .byte

tgtX	.byte
tgtY	.byte

tgtTargetX .byte
tgtTargetY .byte

score   .byte

maxHBVolume .byte
temp	.byte

bgMask .byte

totalDist .byte
babySpeed .byte
;------------------------------------------------
; Start of ROM
;------------------------------------------------
	SEG   Bank0
	ORG   $F000       	; 4k ROM start point

Start 
	CLEAN_START			; Clear RAM and Registers
	
	lda		#0
	sta		ticks	;initialize ticks	
	
	;Initialize colors		
	lda		#PLAYER_COLOR ;Player color
	sta		COLUP0
	
	;Initialize player to center of the screen
	lda		#76
	sta		tgtX
	lda		#92
	sta		tgtY
	lda		#0

	sta		COLUP1
	sta		bgMask
	sta		songVol
	
	lda     #76
	sta		plrX
	lda		#92
	sta		plrY
	
	lda		#$FF
	sta		GRP0
	
	lda		#3
	sta		AUDV0
	lda		#27
	sta		AUDF0
	lda		#8
	sta		AUDC0
	
	lda     #0
	sta		AUDV1
	lda		#12
	sta		AUDC1
	
	lda 	#00
	sta		musicTicks
	sta 	musicCount
	sta		envelope
	 
	lda		#2
	sta		maxHBVolume

	lda		#0
	sta		score
	lda		#1
	sta		babySpeed
	
;------------------------------------------------
; Vertical Blank
;------------------------------------------------
MainLoop
	lda		#0		;Start the vertical blank
	sta		VBLANK
	VERTICAL_SYNC
    lda     #43
    sta     TIM64T ;This sets a timer that we can check via INTIM

	;***** Vertical Blank code goes here
	
	;--Handle reset switch
	lda		SWCHB
	and		#%00000001
	beq		Start
	
	;** Increment ticks
	lda		ticks
	clc
	adc		#4
	cmp		#96
	bne		.noTickReset
	lda		#0
.noTickReset
	clc
	sta 	ticks
	sta		bgIndex
	
	;Want the heartbeat sound to go up and down in 
	; volume, to make the "beat" effect
	lda		ticks
	lsr
	lsr
	lsr
	cmp		#8
	bmi		.goingUp
	eor     #%00001111
.goingUp
	adc		#1
	;and     maxHBVolume
	asl
.decreaseVol
	lsr
	cmp		maxHBVolume
	bpl		.decreaseVol
	
	sta		AUDV0
	
;*** Read the joystick
	lda 	#P0_RIGHT_MASK
	bit		SWCHA
	bne		.notRight
	
	lda		plrX
	cmp		#132	
	beq		.notRight
	adc		#1
	sta		plrX
	
.notRight
	lda		#P0_LEFT_MASK
	bit		SWCHA
	bne		.notLeft
	
	lda		plrX
	cmp		#20
	beq		.notLeft
	sbc		#1
	sta		plrX
.notLeft
	
	
	lda 	#P0_UP_MASK
	bit		SWCHA
	bne		.notUp

	lda		plrY
	cmp		#162
	beq		.notUp
	adc		#2
	sta		plrY

.notUp
	lda		#P0_DOWN_MASK
	bit		SWCHA
	bne		.notDown

	lda		plrY
	cmp		#38
	beq		.notDown
	sbc		#2
	sta		plrY
.notDown
	jmp		$F100
	
	ORG $F100	
	;** Place the player sprite
	sta 	WSYNC
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	lda		plrX
.pos_loop_plr
	sbc		#15				;(2)
	bpl		.pos_loop_plr	;(3)
	
	sta		RESP0			;(3)

	sta		WSYNC	
	eor		#255			;(2)
	tax	
	lda		.hmove_table,x	;(4)
	sta		HMP0			;(3)
	
	sta		WSYNC
	;sta		HMOVE
	
	;Clear the player1 sprite
	lda		#0
	sta		GRP0
	;sta		HMP0
	
	
	;** Place the target sprite
	sta 	WSYNC
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	lda		tgtX
.pos_loop_tgt
	sbc		#15				;(2)
	bpl		.pos_loop_tgt	;(3)

	sta		RESP1			;(3)

	sta		WSYNC	
	eor		#255			;(2)
	tax	
	lda		.hmove_table,x	;(4)
	sta		HMP1			;(3)

	sta		WSYNC
	sta		HMOVE

	;Clear the player1 sprite
	lda		#0
	sta		GRP1
	;sta		HMP1	
	
	
	
	
	
	lda		musicTicks
	adc		#1
	sta		musicTicks
	cmp		TICKS_PER_COUNT
	bne		.notCountTime
	lda 	#0
	sta		musicTicks
	inc		musicCount

	lda		musicCount
	cmp		#96
	bne		.notCountTime
	lda		#0
	sta		musicCount
	
.notCountTime
		
	lda		musicTicks
	bne		.notAttack ;--Cannot be an attack if it isn't a new count
	
	ldx		musicCount
	lda		.song,x
	sta		AUDF1
	;Is this the start of a new note?
	and		NOTE_ATTACK
	beq		.notAttack
	lda		songVol	;Starting volume level
	sta		envelope
	
	
.notAttack
	
	lda envelope
	sta	AUDV1
	
	lda envelope
	cmp #9
	bmi	.envelopeDone
	dec envelope
.envelopeDone
	
	;--Clear collisions 
	sta		CXCLR
	
	;--Set the HB volume based on distance
	lda		#16
	sta		maxHBVolume
	
	lda		plrX
	sbc		tgtX
	bpl		.isPositiveX
	eor		#$FF
.isPositiveX
	sta		temp
	lda		plrY
	sbc		tgtY
	bpl		.isPositiveY
	eor		#$FF
.isPositiveY
	adc		temp
	sta		totalDist
.adjustVolume
	dec 	maxHBVolume
	dec		maxHBVolume
	lsr
	bne	 	.adjustVolume
	lda		maxHBVolume ;;Never let volume get below 1
	ora		#1
	sta		maxHBVolume
	
	;--Points are scored when maxHBVolume is 0E or 0F. Lose points when < 06
	cmp		#$04
	bmi		.loseScore
	cmp		#$07
	bmi		.doneScore
	inc		score
	jmp		.doneScore
.loseScore
	dec score
	bpl .doneScore
	inc score ;--Correct if the score went negative
.doneScore
	lda	score
	cmp	#127 ;--127 is the max score, 0 is the min
	bne	.scoreNotTooBig
	dec score
.scoreNotTooBig
	cmp	#255
	bne	.scoreNotTooSmall
	inc score
.scoreNotTooSmall
	
	;--If score is high enough, make the "baby" visible
	lda		score
	cmp		#SCORE_TO_SEE_BABY
	bpl		.visibleBaby
	lda		#$00
	sta		COLUP1
	jmp 	.doneBaby
.visibleBaby
	lda		#BABY_COLOR
	sta		COLUP1
.doneBaby



	;----AI EVASION CODE
		
;	lda		plrX
;	sbc		tgtX
	;--If this is a small positive number,
	;  we are to the left of the player, and we need to run.
	;  If it is a small positive number, we are to the left, and need to run
;	bpl		.dontRunRight
;	lda 	tgtX
;	adc		babySpeed
;	sta		tgtX
;	jmp		.horizRunDone
;.dontRunRight
;	lda		tgtX
;	sbc		babySpeed
;	sta		tgtX
;.horizRunDone
	;20 to 132
;	lda		tgtX
;	cmp		#132
;	bmi		.tgtXNotTooBig
;	lda		#132
;.tgtXNotTooBig
;	cmp		#20
;	bpl		.tgtXNotTooSmall
;	lda		#20
;.tgtXNotTooSmall
;	sta		tgtX
	
	
;	lda		plrY
;	sbc		tgtY
	;--If this is a positive number,
	;  we are to the below of the player, and we need to run.
	;  otherwise we are to the up, and need to run
;	bpl		.dontRunDown
;.doRunDown
;	lda 	tgtY
;	adc		babySpeed
;	adc		babySpeed
;	sta		tgtY
;	jmp		.vertRunDone
;.dontRunDown
;	lda		tgtY
;	sbc		babySpeed
;	sbc		babySpeed
;	sta		tgtY
;.vertRunDone
	;20 to 132
;	lda		tgtY
;	cmp		#162
;	bmi		.tgtYNotTooBig
;	lda		#162
;.tgtYNotTooBig
;	cmp		#38
;	bpl		.tgtYNotTooSmall
;	lda		#38
;.tgtYNotTooSmall
;	sta		tgtY
	
	;--GOAL: Reach the point diametrically opposite from the player
	lda		plrX
	cmp		#76
	bpl		.playerIsRight
	lda		#132
	sta		tgtTargetX
	jmp		.playerIsLeft
.playerIsRight
	lda		#20
	sta		tgtTargetX
.playerIsLeft
	
	lda		plrY
	cmp		#100
	bpl		.playerIsUp
	lda		#162
	sta		tgtTargetY
	jmp		.playerIsDown
.playerIsUp
	lda		#38
	sta		tgtTargetY
.playerIsDown


	lda		plrY
	lsr
	eor		plrX
	and		#%00000001
	beq		.doY
	
	lda		tgtTargetX
	sbc		tgtX
	bpl		.runRight
	lda 	tgtX
	sbc		babySpeed
	sta		tgtX
	jmp		.horizRunDone
.runRight
	lda		tgtX
	adc		babySpeed
	sta		tgtX
.horizRunDone
	;20 to 132
	lda		tgtX
	cmp		#132
	bmi		.tgtXNotTooBig
	lda		#132
.tgtXNotTooBig
	cmp		#20
	bpl		.tgtXNotTooSmall
	lda		#20
.tgtXNotTooSmall
	sta		tgtX
	jmp		.noDoY
	
.doY	
	lda		tgtTargetY
	sbc		tgtY
	bpl		.doRunDown
	lda 	tgtY
	sbc		babySpeed
	sbc		babySpeed
	sta		tgtY
	jmp		.vertRunDone
.doRunDown
	lda		tgtY
	adc		babySpeed
	adc		babySpeed
	sta		tgtY
.vertRunDone
	;20 to 132
	lda		tgtY
	cmp		#162
	bmi		.tgtYNotTooBig
	lda		#162
.tgtYNotTooBig
	cmp		#38
	bpl		.tgtYNotTooSmall
	lda		#38
.tgtYNotTooSmall
	sta		tgtY
.noDoY
;---END AI CODE	
	
	
	
	
	
	lda		score
	cmp		#SCORE_FOR_BG
	bpl		.yesBG
	lda		#0
	sta		bgMask
	lda		#1
	sta		babySpeed
	jmp		.doneBGMask
.yesBG
	lda		#$FF
	sta		bgMask
	lda		#1 ;--For now, stick with slow baby
	sta		babySpeed
.doneBGMask
	
	
	lda		score
	cmp		#SCORE_FOR_SONG
	bpl		.yesSongVol
	lda		#0
	sta		songVol
	jmp		.doneSongVol
.yesSongVol
	lda		score
	sbc		#SCORE_FOR_SONG
	lsr
	sta		songVol
.doneSongVol
	
	
.waitForVBlank
	lda		INTIM
	bne		.waitForVBlank
	sta		WSYNC


;------------------------------------------------
; Kernel
;------------------------------------------------	
DrawScreen
	
    ; Kernel goes here.	
	;Pixel aspect ratio is 12:7
	
	;---Top zone, no player/target
	ldx		#28+1		 	
.scanline	
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK
	
	txa
	adc		#28+45+46+45
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player
	lda		#$00
	sta		GRP0
	jmp		.donePlayer
.player
	lda		#$FF
	sta		GRP0
.donePlayer

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset
	lda		#0	
.noBgReset
	sta		bgIndex
	
	dex
	sta		WSYNC
	bne		.scanline 		
;--end top


;--begin first target range
	ldx		#45			
.scanline2
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#28+46+45
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player2
	lda		#$00
	sta		GRP0
	jmp		.donePlayer2
.player2
	lda		#$FF
	sta		GRP0
.donePlayer2

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt2
	lda		#$00
	sta		GRP1
	jmp		.doneTgt2
.tgt2
	lda		#$FF
	sta		GRP1
.doneTgt2

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset2
	lda		#0	
.noBgReset2
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline2
;--end first target



;--begin 2nd target		
	ldx		#46		 	
.scanline3
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#28+45
	tay		;Store to use for positioning the target
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player3
	lda		#$00
	sta		GRP0
	jmp		.donePlayer3
.player3
	lda		#$FF
	sta		GRP0
.donePlayer3

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt3
	lda		#$00
	sta		GRP1
	jmp		.doneTgt3
.tgt3
	lda		#$FF
	sta		GRP1
.doneTgt3

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset3
	lda		#0	
.noBgReset3
	sta		bgIndex
	
	dex
	sta		WSYNC
	bne		.scanline3
;--End 2nd target			
			


;--Start 3rd target			
	ldx		#45		
.scanline4
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK
	
	txa
	adc		#28
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player4
	lda		#$00
	sta		GRP0
	jmp		.donePlayer4
.player4
	lda		#$FF
	sta		GRP0
.donePlayer4

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt4
	lda		#$00
	sta		GRP1
	jmp		.doneTgt4
.tgt4
	lda		#$FF
	sta		GRP1
.doneTgt4

	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset4
	lda		#0	
.noBgReset4
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline4					
;--end 3rd target

;--Start bottom zone	
	ldx		#28			
.scanline5
	ldy		bgIndex
	lda		.bgcolors,y
	and		bgMask
	sta		COLUBK

	txa
	adc		#0
	tay
	sbc		plrY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.player5
	lda		#$00
	sta		GRP0
	jmp		.donePlayer5
.player5
	lda		#$FF
	sta		GRP0
.donePlayer5

	tya
	sbc		tgtY
	adc		#16 ;(2) --If in range, carry will be set, A
			    ;    will give index into table
	bcs		.tgt5
	lda		#$00
	sta		GRP1
	jmp		.doneTgt5
.tgt5
	lda		#$FF
	sta		GRP1
.doneTgt5
	
	clc
	lda		bgIndex
	adc		#1
	cmp		#96
	bne		.noBgReset5
	lda		#0	
.noBgReset5
	sta		bgIndex

	dex
	sta		WSYNC
	bne		.scanline5				
;--end bottom zone			
		
;------------------------------------------------
; Overscan
;------------------------------------------------
	lda		#%01000010
	sta		VBLANK
    lda		#36
    sta		TIM64T

	;***** Overscan Code goes here
	lda #$00
	sta COLUBK
	sta COLUPF
	
.waitForOverscan
	lda     INTIM
	bne     .waitForOverscan

	jmp		MainLoop

;------------------------------------------------
; ROM Tables
;------------------------------------------------
	;***** ROM tables go here
	
	ORG $FE00
.hmove_table
	.byte HMOVE_0 
	.byte HMOVE_M01         
	.byte HMOVE_M02        
	.byte HMOVE_M03       
	.byte HMOVE_M04         
	.byte HMOVE_M05          
	.byte HMOVE_M06          
	.byte HMOVE_M07         
	.byte HMOVE_M08       
	.byte HMOVE_M09         
	.byte HMOVE_M10          
	.byte HMOVE_M11          
	.byte HMOVE_M12          
	.byte HMOVE_M13          
	.byte HMOVE_M14          
	.byte HMOVE_M15
	
	;ORG $FE00
.song
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2
	.byte NOTE_A2
	
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_G
	.byte NOTE_G
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_A2
	.byte NOTE_A2
	.byte NOTE_A2
	
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_G
	.byte NOTE_G
	.byte NOTE_G
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	
	.byte NOTE_A | NOTE_ATTACK
	.byte NOTE_A
	.byte NOTE_C | NOTE_ATTACK
	.byte NOTE_C
	.byte NOTE_C | NOTE_ATTACK
	.byte NOTE_C
	.byte NOTE_C
	.byte NOTE_C
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_F
	.byte NOTE_F
	.byte NOTE_F
	
	.byte NOTE_C2 | NOTE_ATTACK
	.byte NOTE_C2
	.byte NOTE_C2
	.byte NOTE_BF2 | NOTE_ATTACK
	.byte NOTE_A2 | NOTE_ATTACK
	.byte NOTE_G | NOTE_ATTACK
	.byte NOTE_F | NOTE_ATTACK
	.byte NOTE_E | NOTE_ATTACK
	
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D | NOTE_ATTACK
	.byte NOTE_D
	.byte NOTE_D
	.byte NOTE_D
	;--Song end
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E
	.byte NOTE_E

	;ORG $FE00
.bgcolors
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46

	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$4a
	.byte #$4a
	.byte #$4a
	.byte #$4a
	
	.byte #$4e
	.byte #$4e
	.byte #$4e
	.byte #$4e
	
	.byte #$4c
	.byte #$4c
	.byte #$4c
	.byte #$4c
	
	.byte #$4a
	.byte #$4a
	.byte #$4a
	.byte #$4a
	
	.byte #$48
	.byte #$48
	.byte #$48
	.byte #$48
	
	.byte #$48
	.byte #$48
	.byte #$48
	.byte #$48
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$46
	.byte #$46
	.byte #$46
	.byte #$46
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
		
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44
	
	.byte #$44
	.byte #$44
	.byte #$44
	.byte #$44

	
;------------------------------------------------
; Interrupt Vectors
;------------------------------------------------
	echo [*-$F000]d, " ROM bytes used"
	ORG    $FFFA
	.word  Start         ; NMI
	.word  Start         ; RESET
	.word  Start         ; IRQ
    
	END